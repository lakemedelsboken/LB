{
  "name": "scrypt",
  "description": "The scrypt crypto library for NodeJS",
  "version": "4.0.7",
  "keywords": [
    "scrypt",
    "password",
    "auth",
    "authentication",
    "encryption",
    "crypto",
    "secret",
    "key",
    "secret key",
    "hash",
    "verify"
  ],
  "author": {
    "name": "Barry Steyn",
    "email": "barry.steyn@gmail.com",
    "url": "http://doctrina.org"
  },
  "engines": {
    "node": ">= 0.10"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/barrysteyn/node-scrypt.git"
  },
  "devDependencies": {
    "tap": "*"
  },
  "dependencies": {
    "nan": "^1.6.2"
  },
  "licenses": [
    {
      "type": "MIT"
    }
  ],
  "bugs": {
    "url": "https://github.com/barrysteyn/node-scrypt/issues"
  },
  "scripts": {
    "test": "npm install && node tests/scrypt-tests.js",
    "install": "node-gyp rebuild"
  },
  "gypfile": true,
  "readme": "# Scrypt For Node/IO\n\n[![Build Status](https://travis-ci.org/barrysteyn/node-scrypt.png?branch=master)](https://travis-ci.org/barrysteyn/node-scrypt) [![npm version](https://badge.fury.io/js/scrypt.svg)](http://badge.fury.io/js/scrypt)\n\nScrypt for Node/IO is a native node/io C++ wrapper for Colin Percival's scrypt utility. \n\nAs should be the case with any security tool, this library should be scrutinized by anyone using it. If you find or suspect an issue with the code- please bring it to my attention and I'll spend some time trying to make sure that this tool is as secure as possible.\n\n# News And Updates\n\n## Node-Scrypt Version 4\nFully compatible with Node versions 0.10x and up and IO. Library rewritten using [nan](https://github.com/rvagg/nan).\n\n## Node-Scrypt Version 3\nVersion 3's main highlight is support for the **Microsoft Windows** platform.\n\n### Node-Scrypt Version 2\nNode-Scrypt version 2.0 is a complete rewrite of the previous module. It's main highlights are:\n\n * Access to the underlying key derivation function\n * Extensive use of node's buffers\n * Easy configuration\n * Removal of scrypt encryption/decryption (this will soon be moved to another module)\n\nThe module consists of four functions:\n\n 1. [params](#params) - a translation function that produces scrypt parameters\n 2. [hash](#hash) - produces a 256 bit hash using scrypt's key derivation function\n 3. [verify](#verify) - verify's a hash produced by this module\n 4. [kdf](#key-derivation-function) - scrypt's underlying key dervivation function\n\nIt also consists of four extra functions that provide [backward compatibility](#backward-compatibility-for-users-of-version-1x) to the previous version.\n\n## Table Of Contents\n\n * [Scrypt](#scrypt)\n * [Installation Instructions](#installation-instructions)\n * [API](#api)\n * [Example Usage](#example-usage)\n * [FAQ](#faq)\n * [Credits](#credits)\n\n## Scrypt\nScrypt is an advanced crypto library used mainly for [key derivation](http://en.wikipedia.org/wiki/Key_derivation_function): More information can be found here:\n\n* [Tarsnap blurb about scrypt](http://www.tarsnap.com/scrypt.html) - Colin Percival (the author of scrypt) explains a bit about it.\n* [Academic paper explaining scrypt](http://www.tarsnap.com/scrypt/scrypt.pdf).\n* [Wikipedia Article on scrypt](http://en.wikipedia.org/wiki/Scrypt).\n\n## Installation Instructions\n\n### Windows\n\n#### Node-Gyp\n\nTo install node-gyp for windows, refer to the [windows specific install instructions](https://github.com/TooTallNate/node-gyp#installation) of the node-gyp documentation (also look [here](https://github.com/TooTallNate/node-gyp/wiki/Visual-Studio-2010-Setup) for helpful hints).\n\n#### OpenSSL\nIt is very important that OpenSSL for windows be installed:\n\n * [OpenSSL For Windows 32 bit](http://slproweb.com/download/Win32OpenSSL-1_0_2.exe)\n * [OpenSSL For Windows 64 bit](http://slproweb.com/download/Win64OpenSSL-1_0_2.exe)\n  \n### Posix Environment Prerequisites (Linux, Mac etc)\n\n#### Node-Gyp\n[Node-gyp](https://github.com/TooTallNate/node-gyp) is needed to build this module. It should be installed globally, that is, with the `-g` switch:\n\n\tnpm install -g node-gyp\n\n### From NPM\n\n    npm install scrypt\n\n### From Source\n\n    git clone https://github.com/barrysteyn/node-scrypt.git\n    cd node-scrypt\n    npm install\n    node-gyp configure build\n\n### Testing\nTo test, go to the folder where scrypt was installed, and type:\n\n    npm test\n\n#### Encodings\nThe following encodings are accepted:\n\n 1. **ascii**\n 2. **utf8**\n 3. **base64**\n 4. **ucs2** \n 5. **binary**\n 6. **hex**\n 7. **buffer**\n\nThe last encoding is node's [Buffer](http://nodejs.org/api/buffer.html) object. Buffer is useful for representing raw binary data and has the ability to translate into any of the encodings mentioned above. It is for these reasons that encodings default to buffer in this module.\n\n### Params\nThe [params function](#params-1) translates human understandable parameters to scrypt's internal parameters. \n\nThe human understandable parameters are as follows:\n\n 1. **maxtime**: the maximum amount of time scrypt will spend when computing the derived key.\n 2. **maxmemfrac**: the maximum fraction of the available RAM used when computing the derived key.\n 3. **maxmem**: the maximum number of bytes of RAM used when computing the derived encryption key. \n\nScrypt's internal parameters are as follows:\n\n 1. **N** - general work factor, iteration count.\n 2. **r** - blocksize in use for underlying hash; fine-tunes the relative memory-cost.\n 3. **p** - parallelization factor; fine-tunes the relative cpu-cost.\n\nFor info on what the above parameters do, read [section 5 of the scrypt ietf draft](http://tools.ietf.org/html/draft-josefsson-scrypt-kdf-01#section-5).\n\n#### How Memory Is Calculated\n`maxmem` is often defaulted to `0`. This does not mean that `0` RAM is used. Instead, memory used is calculated like so (quote from Colin Percival):\n\n> the system [will use] the amount of RAM which [is] specified [as the] fraction of the available RAM, but no more than maxmem, and no less than 1MiB\n\nTherefore at the very least, 1MiB of ram will be used.\n\n### Hash\nThe [hash function](#hash-1) does the following:\n\n * Adds random salt.\n * Creates a HMAC to protect against active attack.\n * Uses the scrypt key derivation function to derive a hash for a key.\n\n#### Hash Format\nAll hashes start with the word *\"scrypt\"*. Next comes the scrypt parameters used in the key derivation function, followed by random salt. Finally, a 256 bit HMAC of previous content is appended, with the key for the HMAC being produced by the scrypt key derivation function. The result is a 768 bit (96 byte) output:\n\n 1. **bytes 0-5**: The word *\"scrypt\"*\n 2. **bytes 6-15**: Scrypt parameters N, r, and p\n 3. **bytes 16-47**: 32 bits of random salt\n 4. **bytes 48-63**: A 16 bit checksum\n 5. **bytes 64-95**: A 32 bit HMAC of bytes 0 to 63 using a key produced by the scrypt key derivation function.\n\nBytes 0 to 63 are left in plaintext. This is necessary as these bytes contain metadata needed for verifying the hash. This information not being encrypted does not mean that security is weakened. What is essential in terms of security is hash **integrity** (meaning that no part of the hashed output can be changed) and that the original password cannot be determined from the hashed output (this is why you are using scrypt - because it does this in a good way). Bytes 64 to 95 is where all this happens.\n\n### Verify\nThe [verify function](#verify-1) determines whether a hash can be derived from a given key and returns a boolean result.\n\n### Key Derivation Function\nThe underlying [scrypt key derivation function](#kdf). This functionality is exposed for users who are quite experienced and need the function for business logic. A good example is [litecoin](https://litecoin.org/) which uses the scrypt key derivation function as a proof of work. The key derivation function in this module is tested against [three of the four test vectors](http://tools.ietf.org/html/draft-josefsson-scrypt-kdf-00#page-11) in the original scrypt paper. The fourth test vector takes too long to computer and is infeasible to use as testing for continuous integration. Nevertheless, it is included in the tests, but commented out - uncomment it and run the tests, but be warned that it is rather taxing on resources.\n\n#### Use Hash To Store Keys\nIf your interested in this module is to produce hashes to store passwords, then I strongly encourage you to use the hash function. The key derivation function does not produce any [message authentication code](http://en.wikipedia.org/wiki/Message_authentication_code) to ensure integrity. You will also have to store the scrypt parameters separately. Lastly, there is no native verify function included in this module.\n\nIn short: If you are going to use this module to store keys, then use the hash function. It has been customized for general key storage and is both easier to use and provides better protection compared to the key derivation function.\n\n### Backward Compatibility For User's Of Version 1.x\nFour extra functions are provided for means of backward compatibility:\n\n 1. [passwordHash](#passwordhash)\n 2. [passwordHashSync](#passwordhashsync)\n 3. [verifyHash](#verifyhash)\n 4. [verifyHashSync](#verifyhashsync)\n\nThe above functions are defaulted to behave exactly like the previous version.\n\n## API\n##### A Note On Error Synchronous Handling\nAll synchronous functionality should be wrapped in a `try ... catch` as exceptions are thrown in case of error. For asynchronous functionality, error are returned as the first argument to the callback function if such an error exists. An error is an object with both an error code and a message describing the error.\n\n##### A Note On Error Asynchronous Handling\nFor asynchronous functionality, an error is thrown if the error is a programmer error. For more information about different error types, see [this](https://www.joyent.com/developers/node/design/errors#) article. For example, specifying the `hashEncoding` for verify that is different to the actual hash's encoding will throw an error. \n\nOn a successful result, the err object of the callback function will be `null` (not `undefined`).\n\n##### Scrypt Parameter Object\nThe scrypt parameter object is a JSON object that must have values for properties **N**, **r** and **p**. For example, it could look like this:\n\n    {\n      N: 1,\n      r: 1,\n      p: 1\n    }\n\n### Params\n`params(maxtime, maxmem, maxmemfrac, callback_function)`\n\n * `maxtime` - [REQUIRED] - a decimal (double) representing the maxtime in seconds for running scrypt. \n * `maxmem` - [OPTIONAL] - an integer, specifying the maximum number of bytes\n * `maxmemfrac` - [OPTIONAL] - a double value between 0.0 and 1.0, representing a normalized percentage value\n * `callback_function` - [OPTIONAL] - if present, will make this function asynchronous\n\n#### Params Config Object\nThe params config object is accessible from `scrypt.params.config`. It has the following default value:\n\n    {\n     maxmem: 0,\n     maxmemfrac: 0.5\n    }\n\n  * `maxmem` - an integer representing the default value maxmem is set to if not explicitly defined in the function call\n  * `maxmemfrac` - a double representing the default value maxmemfrac is set to if not explicitly defined in the function call\n\nRead the section on [how memory is calculated](#how-memory-is-calculated) to get a better understanding of these values.\n\nThe return value will be a [scrypt parameter object](#scrypt-parameter-object)\n\n### Hash\n`hash(key, scrypt_parameters, callback_function)`\n\n * `key` - [REQUIRED] - an [encoded string or buffer](#encodings) representing the key to be hashed\n * `scrypt_parameters` - [REQUIRED] - a JSON object representing the [scrypt's internal parameters](#params)\n * `callback_function` - [OPTIONAL] - if present, will make this function asynchronous\n\n#### Hash Config Object\nThe hash config object is accessible from `scrypt.hash.config`. It has the following default value:\n\n    {\n     keyEncoding: 'buffer', \n     outputEncoding: 'buffer'\n    }\n\n * `keyEncoding` - a string representing the [encoding](#encodings) of the input key\n * `outputEncoding` - a string representing the [encoding](#encodings) of the output returned to the user\n\nThe return value will be an [encoded string or buffer](#encodings) of the [hash format](#hash-format).\n\n### Verify\n`verify(hash, key, callback_function)`\n\n * `hash` - [REQUIRED] - an [encoded string or buffer](#encodings) of the output of the hash function\n * `key` - [REQUIRED] - an [encoded string or buffer](#encodings) representing the key to be hashed\n * `callback_function` - [OPTIONAL] - if present, will make this function asynchronous\n\n#### Verify Config Object\nThe verify config object is accessible from `scrypt.verify.config`. It has the following default value:\n\n    {\n     hashEncoding: 'buffer', \n     keyEncoding: 'buffer'\n    }\n\n * `hashEncoding` - a string representing the [encoding](#encodings) of the input hash\n * `keyEncoding` - a string representing the [encoding](#encodings) of the input key\n\nThe return value will be a `boolean` representing if the hash can be derived from the key\n\n### KDF\n`kdf(key, scrypt_parameters, outputLength, salt, callback_function)`\n\n * `key` - [REQUIRED] - an [encoded string or buffer](#encodings) representing the key to be hashed\n * `scrypt_parameters` - [REQUIRED] - a JSON object representing the [scrypt's internal parameters](#params)\n * `outputLength` - [OPTIONAL] - an integer, representing the size in bytes of the output\n * `salt` - [OPTIONAL] - an [encoded string or buffer](#encodings) representing the value used for salt. If not defined, a random salt will be created.\n * `callback_function` - [OPTIONAL] - if present, will make this function asynchronous\n\nThe return value will be a JSON object with the following properties:\n\n 1. **hash** - the resulting scrypt KDF hash\n 2. **salt** - the salt used to make the hash\n\n#### KDF Config Object\nThe kdf config object is accessible from `scrypt.kdf.config`. It has the following default value:\n\n    { \n     saltEncoding: 'buffer',\n     keyEncoding: 'buffer',\n     outputEncoding: 'buffer',\n     defaultSaltSize: 32,\n     outputLength: 64 \n    }\n \n * `saltEncoding` - a string representing the [encoding](#encodings) of the input salt\n * `keyEncoding` - a string representing the [encoding](#encodings) of the input key\n * `outputEncoding` - a string representing the [encoding](#encodings) of the output returned to the user\n * `defaultSaltSize` - an integer representing the number of bytes used to create a random salt should it be necessary\n * `outputLength` - an integer representing the size of the output in bytes\n\n\n### Backward Compatibility\n#### PasswordHash\n`passwordHash(key, maxtime, maxmem, maxmemfrac, callback_function)`\n\n * `key` - [REQUIRED] - a key string.\n * `maxtime` - [REQUIRED] - a decimal (double) representing the maxtime in seconds for running scrypt. Use 0.1 (100 milliseconds) for interactive login.\n * `maxmem` - [OPTIONAL] - instructs scrypt to use the specified number of bytes of RAM (default 0).\n * `maxmemfrac` - [OPTIONAL] - instructs scrypt to use the specified fraction of RAM (defaults 0.5).\n * `callback_function` - [Optional] - a callback function that will handle processing when result is ready. If this argument is not present, the function will behave in a synchronous manner like the function below.\n\n#### PasswordHashSync\n`passwordHashSync(key, maxtime, maxmem, maxmemfrac)`\n\n * `key` - [REQUIRED] - a password string.\n * `maxtime` - [REQUIRED] - a decimal (double) representing the maxtime in seconds for running scrypt. Use 0.1 (100 milliseconds) for interactive logins.\n * `maxmem` - [OPTIONAL] - instructs scrypt to use the specified number of bytes of RAM (default 0).\n * `maxmemfrac` - [OPTIONAL] - instructs scrypt to use the specified fracion of RAM (defaults 0.5).\n\n#### verifyHash\n`verifyHash(hash, key, callback_function)` \n\n * `hash` - [REQUIRED] - the password created with the above `passwordHash` function.\n * `key` - [REQUIRED] - a password string.\n * `callback_function` - [OPTIONAL] - a callback function that will handle processing when result is ready. If this argument is not present, the function will behave in a synchronous manner like the function below\n\n#### verifyHashSync\n`verifyHashSync(hash, password)`\n\n * `hash` - [REQUIRED] - the password created with the above `passwordHash` function.\n * `password` - [REQUIRED] - a password string.\n\n# Example Usage\n## params\n\n    var scrypt = require(\"scrypt\");\n\tconsole.log(scrypt.params.config); //Outputs the config object to screen\n\n\t//Synchronous\n\ttry {\n\t\t//Uses 0.1 for maxtime, and the values in the config object for maxmem and maxmemfrac\n\t\tvar scryptParameters = scrypt.params(0.1); \n\t\tconsole.log(scryptParameters);\n\t} catch(err) {\n\t\t\n\t}\n\n\t//Asynchronous\n\tscrypt.params(0.1, function(err, scryptParameters) {\n\t\tconsole.log(scryptParameters);\n\t});\n\n## hash\n\t\n\tvar scrypt = require(\"scrypt\");\n\tvar scryptParameters = scrypt.params(0.1);\n\tvar key = new Buffer(\"this is a key\"); //key defaults to buffer in config, so input must be a buffer\n\n\t//Synchronous example that will output in hexidecimal encoding\n\tscrypt.hash.config.outputEncoding = \"hex\";\n\tvar hash = scrypt.hash(key, scryptParameters); //should be wrapped in try catch, but leaving it out for brevity\n\tconsole.log(\"Synchronous result: \"+hash);\n\n\t//Asynchronous example that expects key to be ascii encoded\n\tscrypt.hash.config.keyEncoding = \"ascii\";\n\tscrypt.hash(\"ascii encoded key\", {N: 1, r:1, p:1}, function(err, result){\n\t\t//result will be hex encoded\n\t\t//Note how scrypt parameters was passed as a JSON object\n\t\tconsole.log(\"Asynchronous result: \"+result);\n\t});\n\n## verify\n\n\tvar scrypt = require(\"scrypt\");\n\tvar scryptParameters = scrypt.params(0.1);\n\tscrypt.hash.config.keyEncoding = \"ascii\";\n\tscrypt.verify.config.keyEncoding = \"ascii\";\n\tvar hash = scrypt.hash(\"password\", scryptParameters);\n\n\t//Synchronous\n\tscrypt.verify(hash, \"password\"); //result will be true\n\tscrypt.verify(hash, \"incorrect password\"); //result will be false\n\n\t//Asynchronous\n\tscrypt.verify(hash, \"password\", function(err, result) {\n\t\t//result will be true\n\t});\n\n## kdf\nThe [scrypt paper](http://www.tarsnap.com/scrypt/scrypt.pdf) lists four [test vectors](http://tools.ietf.org/html/draft-josefsson-scrypt-kdf-00#page-11) to test implementation. This example will show how to produce these test vectors from within this module.\n\n#### Test Vector 1\n\n\tvar scrypt = require(\"scrypt\");\n    scrypt.kdf.config.saltEncoding = \"ascii\";\n    var key = new Buffer(\"\");\n\n\t//Synchronous\n    var res = scrypt.kdf(key,{\"N\":16,\"r\":1,\"p\":1},64,\"\");\n\tconsole.log(res.hash.toString(\"hex\"));\n\n\t//Asynchronous\n    scrypt.kdf(key, {\"N\":16,\"r\":1,\"p\":1},64,\"\", function(err, res) {\n\t\tconsole.log(res.hash.toString(\"hex\"));\n    });\n\n#### Test Vector 2\n\n\tvar scrypt = require(\"scrypt\");\n    scrypt.kdf.config.keyEncoding = \"ascii\";\n    var salt = new Buffer(\"NaCl\");\n\n\t//Synchronous\n    var res = scrypt.kdf(\"password\",{\"N\":1024,\"r\":8,\"p\":16},64,salt);\n\tconsole.log(res.hash.toString(\"hex\"));\n\n    scrypt.kdf(\"password\", {\"N\":1024,\"r\":8,\"p\":16},64,salt, function(err, res) {\n\t\tconsole.log(res.hash.toString(\"hex\"));\n    });\n\n\n#### Test Vector 3\n\t\n\tvar scrypt = require(\"scrypt\");\n    scrypt.kdf.config.outputEncoding = \"hex\";\n    var key = new Buffer(\"pleaseletmein\");\n    var salt = new Buffer(\"SodiumChloride\");\n\n\t//Synchronous\n    var res = scrypt.kdf(key,{\"N\":16384,\"r\":8,\"p\":1},64,salt);\n\tconsole.log(res.hash);\n\n\t//Asynchronous\n    scrypt.kdf(key, {\"N\":16384,\"r\":8,\"p\":1},64,salt, function(err, res) {\n\t\tconsole.log(res.hash);\n    });\n\n\n#### Test Vector 4\nNote: This test vector is very taxing in terms of resources.\n\t\n\tvar scrypt = require(\"scrypt\");\n\tscrypt.kdf.config.saltEncoding = \"ascii\";\n\tscrypt.kdf.config.keyEncoding = \"ascii\";\n\n\t//Synchronous\n    var res = scrypt.kdf(\"pleaseletmein\",{\"N\":1048576,\"r\":8,\"p\":1},64,\"SodiumChloride\");\n\tconsole.log(res.hash.toString(\"hex\"));\n\n\t//Asynchronous\n    scrypt.kdf(\"pleaseletmein\", {\"N\":1048576,\"r\":8,\"p\":1},64,\"SodiumChloride\", function(err, res) {\n\t\tconsole.log(res.hash.toString(\"hex\"));\n    });\n\n## Backward Compatibility Functions\nThese examples illustrate how to use the backward compatibility functions.\n### Asynchronous Authentication And Verification\nFor interactive authentication, set `maxtime` to `0.1` - 100 milliseconds (although you should ensure that 100 milliseconds on your hardware is sufficiently secure).\n\n#### To create a password hash\n \n    var scrypt = require(\"scrypt\");\n    var password = \"This is a password\";\n    var maxtime = 0.1;\n\n    scrypt.passwordHash(password, maxtime, function(err, pwdhash) {\n        if (!err) {\n            //pwdhash should now be stored in the database\n        }\n    });\n\nNote: `maxmem` and `maxmemfrac` can also be passed to hash function. If they are not passed, then `maxmem` defaults to `0` and `maxmemfrac` defaults to `0.5`. If these values are to be passed, then they must be passed after `maxtime`  and before the callback function like so:\n    var scrypt = require(\"scrypt\");\n    var password = \"This is a password\";\n    var maxtime = 0.1;\n    var maxmem = 0, maxmemfrac = 0.5;\n\n    scrypt.passwordHash(password, maxtime, maxmem, maxmemfrac, function(err, pwdhash) {\n        if (!err) {\n            //pwdhash should now be stored in the database\n        }\n    });\n\n#### To verify a password hash\n\n    var scrypt = require(\"scrypt\");\n    var password = \"This is a password\";\n    var hash; //This should be obtained from the database\n\n    scrypt.verifyHash(hash, password, function(err, result) {\n        if (!err)\n            return result; //Will be True\n        \n        return False;    \n    });\n\n### Synchronous Authentication And Verification\nAgain, for interactive authentication, set `maxtime` to `0.1` - 100 milliseconds. \n\n#### To create a password hash\n \n    var scrypt = require(\"scrypt\");\n    var password = \"This is a password\";\n    var maxtime = 0.1;\n\n    var hash = scrypt.passwordHashSync(password, maxtime);\n\nNote: `maxmem` and `maxmemfrac` can also be passed to hash function. If they are not passed, then `maxmem` defaults to `0` and `maxmemfrac` defaults to `0.5`. If these values are to be passed, then they must be passed after `maxtime`  and before the callback function like so:\n\n    var scrypt = require(\"scrypt\");\n    var password = \"This is a password\";\n    var maxtime = 0.1;\n    var maxmem = 0, maxmemfrac = 0.5;\n\n    var hash = scrypt.passwordHashSync(password, maxtime, maxmem, maxmemfrac);\n\n#### To verify a password hash\n\n    var scrypt = require(\"scrypt\");\n    var password = \"This is a password\";\n    var hash; //This should be obtained from the database\n\n    var result = scrypt.verifyHashSync(hash, password);\n\nNote: There is no error description for the synchronous version. Therefore, if an error occurs, it will just return its result as `false`.\n\n## FAQ\n### General\n#### What Platforms Are Supported?\nThis module supports most posix platforms, as well as Microsoft Windows. It has been tested on the following platforms: **Linux**, **MAC OS**, **SmartOS** (so its ready for Joyent Cloud) and **Microsoft Windows**. It also works on FreeBSD, OpenBSD, SunOS etc.\n\n### Scrypt\n#### Why Use Scrypt?\n\nIt is probably the most advanced key derivation function available. This is is quote taken from a comment in hacker news:\n\n>Passwords hashed with scrypt with sufficiently-high strength values (there are 3 tweakable input numbers) are fundamentally impervious to being cracked. I use the word \"fundamental\" in the literal sense, here; even if you had the resources of a large country, you would not be able to design any hardware (whether it be GPU hardware, custom-designed hardware, or otherwise) which could crack these hashes. Ever. (For sufficiently-small definitions of \"ever\". At the very least \"within your lifetime\"; probably far longer.)\n\n#### What Are The Pros And Cons For Using Scrypt\n##### Pros\n\n* The scrypt algorithm has been published by [IETF](http://en.wikipedia.org/wiki/IETF) as an [Internet Draft](http://en.wikipedia.org/wiki/Internet_Draft) and is thus on track to becoming a standard. See [here](https://tools.ietf.org/html/draft-josefsson-scrypt-kdf-00) for the draft.\n* It is being actively used in production at [Tarsnap](http://www.tarsnap.com/).\n* It is much more secure than bcrypt.\n* It is designed to be future proof against attacks with future (and more advanced) hardware.\n* It is designed to defend against large scale custom hardware attacks.\n* It is production ready.\n* There is a scrypt library for most major scripting languages (Python, Ruby etc). Now this module provides the library for NodeJS :)\n\nI will end this section with a quote from Colin Percival (author of scrypt):\n\n> We estimate that on modern (2009) hardware, if 5 seconds are spent computing a derived key, the cost of a hardware brute-force attack against scrypt is roughly 4000 times greater than the cost of a similar attack against bcrypt (to find the same password), and 20000 times greater than a similar attack against PBKDF2.\n\n##### Cons\nThere is just one con I can think of: It is a relatively new library (only been around since 2009). Cryptographers don't really like new libraries for production deployment as it has not been *battle tested*. That being said, it is being actively used in [Tarsnap](http://www.tarsnap.com/) (as mentioned above) and the author is very active.\n\n### Hash\n#### What Are The Essential Properties For Storing Passwords\nStoring passwords requires three essential properties\n\n* The password must not be stored in plaintext. (Therefore it is hashed).\n* The password hash must be salted. (Making a rainbow table attack very difficult to pull off).\n* The salted hash function must not be fast. (If someone does get hold of the salted hashes, their only option will be brute force which will be very slow).\n\nAs an example of how storing passwords can be done badly, take [LinkedIn](http://www.linkedin.com). In 2012, they [came under fire](http://thenextweb.com/socialmedia/2012/06/06/bad-day-for-linkedin-6-5-million-hashed-passwords-reportedly-leaked-change-yours-now/#!rS1HT) for using unsalted hashes to store their passwords. As most commentators at the time were focusing no salt being present, the big picture was missed. In fact, their biggest problem was that they used [sha1](http://en.wikipedia.org/wiki/SHA-1), a very fast hash function.\n\nThis module's [hash function](#hash-1) provides all the above properties\n\n#### If random salts are used for each hash, why does each hash start with *c2NyeXB0* when using passwordHash\nAll hashes start with the word *\"scrypt\"*. The reason for this is because I am sticking to Colin Percival's (the creator of scrypt) hash reference implementation whereby he starts off each hash this way. The base64 encoding of the ascii *\"scrypt\"* is *c2NyeXB0*. Seeing as *passwordHash* defaults it's output to base64, every hash produced will start with *c2NyeXB0*. Next is the scrypt parameter. Users of scrypt normally do not change this information once it is settled upon (hence this will also look the same for each hash). \n\nTo illustrate with an example, I have hashed two password: *password1* and *password2*. Their outputs are as follows:\n\n    password1\n    c2NyeXB0AAwAAAAIAAAAAcQ0zwp7QNLklxCn14vB75AYWDIrrT9I/7F9+lVGBfKN/1TH2hs\n    /HboSy1ptzN0YzHJhC7PZIEPQzf2nuoaqVZg8VkKEJlo8/QaH7qjU2VwB\n    \n    password2\n    c2NyeXB0AAwAAAAIAAAAAZ/+bp8gWcTZgEC7YQZeLLyxFeKRRdDkwbaGeFC0NkdUr/YFAWY\n    /UwdOH4i/PxW48fXeXBDOTvGWtS3lLUgzNM0PlJbXhMOGd2bke0PvTSnW\n\nAs one can see from the above example, both hashes start off by looking similar (they both start with *c2NyeXB0AAwAAAAIAAAAA* - as explained above), but after this, things change very rapidly. In fact, I hashed the password *password1* again:\n\n    password1\n    c2NyeXB0AAwAAAAIAAAAATpP+fdQAryDiRmCmcoOrZa2mZ049KdbA/ofTTrATQQ+m\n    0L/gR811d0WQyip6p2skXVEMz2+8U+xGryFu2p0yzfCxYLUrAaIzaZELkN2M6k0\n\nCompare this hash to the one above. Even though they start off looking similar, their outputs are vastly different (even though it is the same password being hashed). This is because of the **random** salt that has been added, ensuring that no two hashes will ever be identical, even if the password that is being hashed is the same.\n\nFor those that are curious or paranoid, please look at how the hash is both [produced](https://github.com/barrysteyn/node-scrypt/blob/master/src/scryptwrapper/hash.c#L37-81) and [verified](https://github.com/barrysteyn/node-scrypt/blob/master/src/scryptwrapper/hash.c#L83-122) (you are going to need some knowledge of the [C language](http://c.learncodethehardway.org/book/) for this). \n\n## Credits\nThe scrypt library is Colin Percival's [scrypt](http://www.tarsnap.com/scrypt.html) project. This includes the encryption/decryption functions which are basically just wrappers into this library.\n\nThe password hash and verify functions are also very heavily influenced by the scrypt source code, with most functionality being copied from various placed within scrypt.\n\nSyed Beparey was instrumental in getting the Windows build working, with most of the Windows build based off the work done by Dinesh Shanbhag.\n",
  "readmeFilename": "Readme.md",
  "homepage": "https://github.com/barrysteyn/node-scrypt",
  "_id": "scrypt@4.0.7",
  "_shasum": "25c6722792d22ba06b6ccc92fb21e03137f8eb1d",
  "_from": "scrypt@",
  "_resolved": "https://registry.npmjs.org/scrypt/-/scrypt-4.0.7.tgz"
}
