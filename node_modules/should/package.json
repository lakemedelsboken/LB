{
  "name": "should",
  "description": "test framework agnostic BDD-style assertions",
  "version": "7.0.1",
  "author": {
    "name": "TJ Holowaychuk",
    "email": "tj@vision-media.ca"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/shouldjs/should.js.git"
  },
  "homepage": "https://github.com/shouldjs/should.js",
  "scripts": {
    "test": "mocha -R mocha-better-spec-reporter --check-leaks ./test/*.test.js ./test/**/*.test.js",
    "zuul": "zuul -- ./test/**/*.test.js ./test/*.test.js",
    "browser": "gulp script"
  },
  "devDependencies": {
    "browserify": "latest",
    "gulp": "^3.8.10",
    "gulp-header": "^1.2.2",
    "gulp-load-plugins": "^0.5.1",
    "gulp-rename": "^1.2.0",
    "gulp-uglify": "^1.0.1",
    "gulp-util": "^2.2.14",
    "mocha": "latest",
    "mocha-better-spec-reporter": "latest",
    "vinyl-source-stream2": "^0.1.1",
    "zuul": "latest"
  },
  "keywords": [
    "test",
    "bdd",
    "assert",
    "should"
  ],
  "main": "./index.js",
  "license": "MIT",
  "dependencies": {
    "should-equal": "0.5.0",
    "should-format": "0.3.0",
    "should-type": "0.2.0"
  },
  "readme": "# should.js\r\n\r\n[![Join the chat at https://gitter.im/shouldjs/should.js](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/shouldjs/should.js)\r\n\r\n[![Build Status](https://travis-ci.org/shouldjs/should.js.svg?branch=master)](https://travis-ci.org/shouldjs/should.js)\r\n\r\n[![Selenium Test Status](https://saucelabs.com/browser-matrix/shouldjs.svg)](https://saucelabs.com/u/shouldjs)\r\n\r\n_should_ is an expressive, readable, framework-agnostic assertion library. The main goals of this library are __to be expressive__ and __to be helpful__. It keeps your test code clean, and your error messages helpful.\r\n\r\nBy default (when you `require('should')`) _should_ extends the `Object.prototype` with a single non-enumerable getter that allows you to express how that object should behave. It also returns itself when required with `require`.\r\n\r\nIt is also possible to use should.js without getter (it will not even try to exetend Object.prototype), just `require('should/as-function')`. Or if you already use version that auto add getter, you can call `.noConflict` function.\r\n\r\n**Results of `(something).should` getter and `should(something)` in most situations the same**\r\n\r\n### Upgrading instructions\r\n\r\nPlease check [wiki page](https://github.com/shouldjs/should.js/wiki/Breaking-changes) for upgrading instructions.\r\n\r\n### FAQ\r\n\r\nYou can take look in [FAQ](https://github.com/shouldjs/should.js/wiki/FAQ).\r\n\r\n## Example\r\n```javascript\r\nvar should = require('should');\r\n\r\nvar user = {\r\n    name: 'tj'\r\n  , pets: ['tobi', 'loki', 'jane', 'bandit']\r\n};\r\n\r\nuser.should.have.property('name', 'tj');\r\nuser.should.have.property('pets').with.lengthOf(4);\r\n\r\n// If the object was created with Object.create(null)\r\n// then it doesn't inherit `Object.prototype`, so it will not have `.should` getter\r\n// so you can do:\r\nshould(user).have.property('name', 'tj');\r\n\r\n// also you can test in that way for null's\r\nshould(null).not.be.ok();\r\n\r\nsomeAsyncTask(foo, function(err, result){\r\n  should.not.exist(err);\r\n  should.exist(result);\r\n  result.bar.should.equal(foo);\r\n});\r\n```\r\n## To begin\r\n\r\n 1. Install it:\r\n\r\n    ```bash\r\n    $ npm install should --save-dev\r\n    ```\r\n\r\n 2. Require it and use:\r\n\r\n    ```js\r\n    var should = require('should');\r\n\r\n    (5).should.be.exactly(5).and.be.a.Number();\r\n    ```\r\n\r\n    ```js\r\n    var should = require('should/as-function');\r\n\r\n    should(10).be.exactly(5).and.be.a.Number();\r\n    ```\r\n\r\n## In browser\r\n\r\nWell, even when browsers by complains of authors has 100% es5 support, it does not mean it has no bugs. Please see [wiki](https://github.com/shouldjs/should.js/wiki/Known-Bugs) for known bugs.\r\n\r\nIf you want to use _should_ in browser, use the `should.js` file in the root of this repository, or build it yourself. To build a fresh version:\r\n\r\n```bash\r\n$ npm install\r\n$ gulp script\r\n```\r\n\r\nThe script is exported to `window.Should`. It is the same as using `should` statically:\r\n\r\n```js\r\nShould(5).be.exactly(5)\r\n```\r\n\r\nAlso, in the case of node.js, `Object.prototype` is extended with `should` (hence the capital S in `window.Should`):\r\n\r\n```js\r\nwindow.should.be.exactly(window);\r\n// the same\r\n// window is host object\r\nshould.be.exactly(window);\r\n// you should not really care about it\r\n\r\n(5).should.be.exactly(5);\r\n```\r\nYou can easy install it with npm or bower:\r\n```\r\nnpm install should --save-dev\r\n# or\r\nbower install shouldjs/should.js\r\n```\r\n\r\n## API docs\r\n\r\nActual api docs generated by jsdoc comments and available at [http://shouldjs.github.io](http://shouldjs.github.io).\r\n\r\n## Usage examples\r\n\r\nPlease look on usage in [examples](https://github.com/shouldjs/examples)\r\n\r\n## .not\r\n\r\n`.not` negates the current assertion.\r\n\r\n## .any\r\n\r\n`.any` allow for assertions with multiple parameters to assert any of the parameters (but not all). This is similar to the native JavaScript [array.some](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some).\r\n\r\n# Assertions\r\n## chaining assertions\r\n\r\nEvery assertion will return a `should.js`-wrapped Object, so assertions can be chained.\r\nTo help chained assertions read more clearly, you can use the following helpers anywhere in your chain: `.an`, `.of`, `.a`, `.and`, `.be`, `.have`, `.with`, `.is`, `.which`. Use them for better readability; they do nothing at all.\r\nFor example:\r\n```js\r\nuser.should.be.an.instanceOf(Object).and.have.property('name', 'tj');\r\nuser.pets.should.be.instanceof(Array).and.have.lengthOf(4);\r\n```\r\nAlmost all assertions return the same object - so you can easy chain them. But some (eg: `.length` and `.property`) move the assertion object to a property value, so be careful.\r\n\r\n## Adding own assertions\r\n\r\nAdding own assertion is pretty easy. You need to call `should.Assertion.add` function. It accept 2 arguments:\r\n\r\n1. name of assertion method (string)\r\n2. assertion function (function)\r\n\r\nWhat assertion function should do. It should check only positive case. `should` will handle `.not` itself.\r\n`this` in assertion function will be instance of `should.Assertion` and you **must** define in any way this.params object\r\n in your assertion function call before assertion check happen.\r\n\r\n`params` object can contain several fields:\r\n\r\n- `operator` - it is string which describe your assertion\r\n- `actual` it is actual value, you can assume it is your own this.obj if you need to define you own\r\n- `expected` it is any value that expected to be matched this.obj\r\n\r\nYou can assume its usage in generating AssertionError message like: expected `obj`? || this.obj not? `operator` `expected`?\r\n\r\nIn `should` sources appeared 2 kinds of usage of this method.\r\n\r\nFirst not preferred and used **only** for shortcuts to other assertions, e.g how `.should.be.true()` defined:\r\n\r\n```javascript\r\nAssertion.add('true', function() {\r\n    this.is.exactly(true);\r\n});\r\n```\r\nThere you can see that assertion function do not define own `this.params` and instead call within the same assertion `.exactly`\r\nthat will fill `this.params`. **You should use this way very carefully, but you can use it**.\r\n\r\nSecond way preferred and i assume you will use it instead of first.\r\n\r\n```javascript\r\nAssertion.add('true', function() {\r\n    this.params = { operator: 'to be true', expected: true };\r\n\r\n    should(this.obj).be.exactly(true);\r\n});\r\n```\r\nin this case this.params defined and then used new assertion context (because called `.should`). Internally this way does not\r\n create any edge cases as first.\r\n\r\n```javascript\r\nAssertion.add('asset', function() {\r\n    this.params = { operator: 'to be asset' };\r\n\r\n    this.obj.should.have.property('id').which.is.a.Number();\r\n    this.obj.should.have.property('path');\r\n})\r\n\r\n//then\r\n> ({ id: '10' }).should.be.an.asset();\r\nAssertionError: expected { id: '10' } to be asset\r\n    expected '10' to be a number\r\n\r\n> ({ id: 10 }).should.be.an.asset();\r\nAssertionError: expected { id: 10 } to be asset\r\n    expected { id: 10 } to have property path\r\n```\r\n\r\n\r\n## Contributions\r\n\r\n[Actual list of contributors](https://github.com/visionmedia/should.js/graphs/contributors) if you want to show it your friends.\r\n\r\nTo run the tests for _should_ simply run:\r\n\r\n    $ npm test\r\n\r\nSee also [CONTRIBUTING](./CONTRIBUTING.md).\r\n\r\n## OMG IT EXTENDS OBJECT???!?!@\r\n\r\nYes, yes it does, with a single getter _should_, and no it won't break your code, because it does this **properly** with a non-enumerable property.\r\n\r\nAlso it is possible use it without extension.\r\n\r\n## License\r\n\r\nMIT &copy; 2010-2014 TJ Holowaychuk\r\n",
  "readmeFilename": "Readme.md",
  "bugs": {
    "url": "https://github.com/shouldjs/should.js/issues"
  },
  "_id": "should@7.0.1",
  "_shasum": "098130966e3d72f9c14fa4b81f6b64c24fc87f5f",
  "_from": "should@",
  "_resolved": "https://registry.npmjs.org/should/-/should-7.0.1.tgz"
}
