{
  "name": "xml-stream",
  "description": "XML stream to JavaScript object converter based on Expat.",
  "keywords": [
    "xml",
    "parser",
    "expat"
  ],
  "version": "0.4.3",
  "author": {
    "name": "AssistUnion",
    "email": "info@assistunion.com"
  },
  "maintainers": [
    {
      "name": "Anatoly Ressin",
      "email": "anatoly@assistunion.com"
    },
    {
      "name": "Dimitry Solovyov",
      "email": "dimituri@gmail.com",
      "url": "http://100-hour.com"
    }
  ],
  "repository": {
    "type": "git",
    "url": "git://github.com/assistunion/xml-stream.git"
  },
  "dependencies": {
    "iconv": "~2.0.0",
    "node-expat": "~2.0.0"
  },
  "directories": {
    "lib": "./lib"
  },
  "main": "index",
  "readme": "# XmlStream\n\nXmlStream is a Node.js XML stream parser and editor, based on\n[node-expat](https://github.com/astro/node-expat) (libexpat SAX-like parser\nbinding).\n\n    $ npm install xml-stream\n\n## Rationale\n\nWhen working with large XML files, it is probably a bad idea to use an XML to\nJavaScript object converter, or simply buffer the whole document in memory.\nThen again, a typical SAX parser might be too low-level for some tasks (and\noften a real pain).\n\nThis is why we've rolled our own stream parser that tries to address these\nshortcomings. It processes an XML stream chunk by chunk and fires events only\nfor nodes of interest, matching them with CSS-like selectors.\n\n## Events\n\nSupported events:\n\n* `data` on outgoing data chunk,\n* `end` when parsing has ended,\n* `startElement[: selector]` on opening tag for selector match,\n* `updateElement[: selector]` on finished node for selector match\n  with its contents buffered,\n* `endElement[: selector]` on closing tag for selector match,\n* `text[: selector]` on tag text for selector match.\n\nWhen adding listeners for `startElement`, `updateElement`, and `text` the\ncallback can modify the provided node, before it is sent to the consumer.\n\nSelector syntax is CSS-like and currently supports:\n\n* `ancestor descendant`\n* `parent > child`\n\nTake a look at the examples for more information.\n\n## Element Node\n\nEach of the four node events has a callback with one argument. When parsing,\nthis argument is set to the current matched node. Having a chunk of XML like\nthis:\n\n```xml\n<item id=\"123\" type=\"common\">\n  <title>Item Title</title>\n  <description>Description of this item.</description>\n  (text)\n</item>\n```\n\nThe structure of the **item** element node would be:\n\n```javascript\n{\n  title: 'Item Title',\n  description: 'Description of this item.',\n  '$': {\n    'id': '123',\n    'type': 'common'\n  },\n  '$name': 'item',\n  '$text': '(text)'\n}\n```\n\nNaturally, element text and child elements wouldn't be known until discovered\nin the stream, so the structure may differ across events. The complete\nstructure as displayed should be available on **updateElement**. The **$name**\nis not available on **endElement**.\n\n# Collecting Children\n\nIt is sometimes required to select elements that have many children with\none and the same name. Like this XML:\n\n```xml\n<item id=\"1\">\n  <subitem>one</subitem>\n  <subitem>two</subitem>\n</item>\n<item id=\"2\">\n  <subitem>three</subitem>\n  <subitem>four</subitem>\n  <subitem>five</subitem>\n</item>\n```\n\nBy default, parsed element node contains children as properties. In the case\nof several children with same names, the last one would overwrite others.\nTo collect all of *subitem* elements in an array use **collect**:\n\n```javascript\nxml.collect('subitem');\nxml.on('endElement: item', function(item) {\n  console.log(item);\n})\n```\n\n# Preserving Elements and Text\n\nBy default, element text is returned as one concatenated string. In this XML:\n\n```xml\n<item>\n  one <a>1</b>\n  two <a>2</b>\n</item>\n```\n\nThe value of **$text** for *item* would be: `one 1 two 2` without any\nindication of the order of element *a*, element *b*, and text parts.\nTo preserve this order:\n\n```javascript\nxml.preserve('item');\nxml.on('endElement: item', function(item) {\n  console.log(item);\n})\n```\n\n# Pause and resume parsing\n\nIf you want parsing to pause (for example, until some asynchronous operation \nof yours is finished), you can pause and resume XML parsing:\n```javascript\nxml.pause();\nmyAsyncFunction( function() {\n  xml.resume();\n});\n```\nBeware that resume() **must not** be called from within a handler callback.\n\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/assistunion/xml-stream/issues"
  },
  "_id": "xml-stream@0.4.3",
  "dist": {
    "shasum": "135c7e1e2ad0e43daf3540cc5d8cf5afeafe552c"
  },
  "_from": "xml-stream@",
  "_resolved": "https://registry.npmjs.org/xml-stream/-/xml-stream-0.4.3.tgz"
}
